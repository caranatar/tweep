/// An enum of the types of errors that can be generated by `tweep`
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum ErrorKind {
    /// Passage header has no name specified
    EmptyName,

    /// Passage header has whitespace before sigil `::`
    LeadingWhitespace,

    /// Passage header has metadata and tags in wrong order
    MetadataBeforeTags,

    /// Passage header is missing sigil `::`
    MissingSigil,

    /// Passage name has an unescaped `[` character
    UnescapedOpenSquare,

    /// Passage name has an unescaped `{` character
    UnescapedOpenCurly,

    /// Passage name has an unescaped `]` character
    UnescapedCloseSquare,

    /// Passage name has an unescaped `}` character
    UnescapedCloseCurly,

    /// Passage header has an unclosed tag block
    UnclosedTagBlock,

    /// An error was encountered when attempting to parse from the given [`Path`](std::path::Path).
    /// Contains the path string and the error string
    BadInputPath(String, String),
}

#[cfg(feature = "issue-names")]
impl ErrorKind {
    /// Gets a string representation of a `ErrorKind` variant's name
    ///
    /// Enabled with "issue-names" feature
    pub fn get_name(&self) -> &str {
        match self {
            ErrorKind::EmptyName => "EmptyName",
            ErrorKind::LeadingWhitespace => "LeadingWhitespace",
            ErrorKind::MetadataBeforeTags => "MetadataBeforeTags",
            ErrorKind::MissingSigil => "MissingSigil",
            ErrorKind::UnescapedOpenSquare => "UnescapedOpenSquare",
            ErrorKind::UnescapedOpenCurly => "UnescapedOpenCurly",
            ErrorKind::UnescapedCloseSquare => "UnescapedCloseSquare",
            ErrorKind::UnescapedCloseCurly => "UnescapedCloseCurly",
            ErrorKind::UnclosedTagBlock => "UnclosedTagBlock",
            ErrorKind::BadInputPath(_, _) => "BadInputPath",
        }
    }
}

impl std::fmt::Display for ErrorKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                ErrorKind::EmptyName => "Passage header has an empty name".to_string(),
                ErrorKind::LeadingWhitespace =>
                    "Passage header has whitespace before sigil (::)".to_string(),
                ErrorKind::MetadataBeforeTags =>
                    "Passage header has metadata before tags".to_string(),
                ErrorKind::MissingSigil => "Passage header missing sigil (::)".to_string(),
                ErrorKind::UnescapedOpenSquare =>
                    "Unescaped [ character in passage header".to_string(),
                ErrorKind::UnescapedOpenCurly =>
                    "Unescaped { character in passage header".to_string(),
                ErrorKind::UnescapedCloseSquare =>
                    "Unescaped ] character in passage header".to_string(),
                ErrorKind::UnescapedCloseCurly =>
                    "Unescaped } character in passage header".to_string(),
                ErrorKind::UnclosedTagBlock => "Unclosed tag block in passage header".to_string(),
                ErrorKind::BadInputPath(path, err_str) =>
                    format!("Error opening path {}: {}", path, err_str),
            }
        )
    }
}
